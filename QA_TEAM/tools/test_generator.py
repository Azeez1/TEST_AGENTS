"""
Test Generator Tool
Generates pytest test code for functions and classes
"""

from claude_agent_sdk import tool
import json
from pathlib import Path
from typing import Dict, List


@tool(
    "generate_unit_tests",
    "Generate pytest unit tests for functions or classes",
    {
        "module_name": str,  # Name of the module (e.g., "story_generator")
        "components": list,  # List of functions/classes to test
        "output_path": str  # Where to save test file
    }
)
async def generate_unit_tests(args):
    """
    Generate unit test file for given components
    """
    module_name = args["module_name"]
    components = args["components"]
    output_path = args.get("output_path", f"tests/test_{module_name}.py")

    # Generate test code
    test_code = _generate_test_file(module_name, components)

    # Ensure output directory exists
    output_file = Path(output_path)
    output_file.parent.mkdir(parents=True, exist_ok=True)

    # Write test file
    output_file.write_text(test_code)

    result = {
        "status": "success",
        "output_path": str(output_file),
        "test_count": len(components) * 3,  # Estimate: 3 tests per component
        "module_tested": module_name
    }

    return {
        "content": [{
            "type": "text",
            "text": json.dumps(result, indent=2)
        }]
    }


@tool(
    "generate_integration_tests",
    "Generate integration tests for module interactions",
    {
        "test_name": str,  # Name of integration test (e.g., "story_generation_workflow")
        "modules": list,  # List of modules involved
        "workflow_description": str,  # Description of workflow to test
        "output_path": str
    }
)
async def generate_integration_tests(args):
    """
    Generate integration test file
    """
    test_name = args["test_name"]
    modules = args["modules"]
    workflow_desc = args["workflow_description"]
    output_path = args.get("output_path", f"tests/test_integration_{test_name}.py")

    # Generate integration test code
    test_code = _generate_integration_test_file(test_name, modules, workflow_desc)

    # Write file
    output_file = Path(output_path)
    output_file.parent.mkdir(parents=True, exist_ok=True)
    output_file.write_text(test_code)

    result = {
        "status": "success",
        "output_path": str(output_file),
        "test_type": "integration",
        "modules_tested": modules
    }

    return {
        "content": [{
            "type": "text",
            "text": json.dumps(result, indent=2)
        }]
    }


@tool(
    "create_fixtures",
    "Generate pytest fixtures in conftest.py",
    {
        "fixtures": list,  # List of fixture definitions
        "output_path": str  # Path to conftest.py
    }
)
async def create_fixtures(args):
    """
    Generate conftest.py with fixtures
    """
    fixtures = args["fixtures"]
    output_path = args.get("output_path", "tests/conftest.py")

    # Generate conftest code
    conftest_code = _generate_conftest_file(fixtures)

    # Write file
    output_file = Path(output_path)
    output_file.parent.mkdir(parents=True, exist_ok=True)
    output_file.write_text(conftest_code)

    result = {
        "status": "success",
        "output_path": str(output_file),
        "fixtures_created": len(fixtures)
    }

    return {
        "content": [{
            "type": "text",
            "text": json.dumps(result, indent=2)
        }]
    }


def _generate_test_file(module_name: str, components: List[Dict]) -> str:
    """Generate complete test file content"""

    imports = f'''"""
Tests for {module_name} module
Generated by Test Agent
"""

import pytest
from unittest.mock import Mock, patch, MagicMock
from {module_name} import *

'''

    test_classes = []

    for component in components:
        if component.get("type") == "function":
            test_classes.append(_generate_function_tests(component))
        elif component.get("type") == "class":
            test_classes.append(_generate_class_tests(component))

    return imports + "\n\n".join(test_classes)


def _generate_function_tests(func_info: Dict) -> str:
    """Generate test class for a function"""
    func_name = func_info.get("name", "unknown_function")
    class_name = f"Test{func_name.replace('_', ' ').title().replace(' ', '')}"

    template = f'''class {class_name}:
    """Tests for {func_name}()"""

    def test_{func_name}_when_valid_input_then_returns_expected(self):
        """Test happy path with valid input"""
        # Arrange
        # TODO: Set up test data
        test_input = None

        # Act
        result = {func_name}(test_input)

        # Assert
        assert result is not None
        # TODO: Add specific assertions

    def test_{func_name}_when_empty_input_then_handles_gracefully(self):
        """Test edge case: empty input"""
        # Arrange
        empty_input = None  # TODO: Define empty input

        # Act
        result = {func_name}(empty_input)

        # Assert
        # TODO: Define expected behavior for empty input
        assert True  # Placeholder

    def test_{func_name}_when_invalid_input_then_raises_error(self):
        """Test error case: invalid input"""
        # Arrange
        invalid_input = None  # TODO: Define invalid input

        # Act & Assert
        with pytest.raises(Exception):  # TODO: Specify exception type
            {func_name}(invalid_input)
'''

    # Add mock test if function likely needs mocking
    if _needs_mocking(func_info):
        template += f'''
    @patch('{module_name}.external_dependency')  # TODO: Specify actual dependency
    def test_{func_name}_with_mocked_dependency(self, mock_dep):
        """Test with mocked external dependency"""
        # Arrange
        mock_dep.return_value = "mocked_response"
        test_input = None  # TODO: Set up test input

        # Act
        result = {func_name}(test_input)

        # Assert
        assert result is not None
        mock_dep.assert_called_once()
'''

    return template


def _generate_class_tests(class_info: Dict) -> str:
    """Generate test class for a class"""
    class_name = class_info.get("name", "UnknownClass")
    test_class_name = f"Test{class_name}"

    template = f'''class {test_class_name}:
    """Tests for {class_name}"""

    @pytest.fixture
    def instance(self):
        """Create instance for testing"""
        # TODO: Provide necessary initialization parameters
        return {class_name}()

    def test_init_when_valid_params_then_initializes(self):
        """Test initialization"""
        # Arrange & Act
        obj = {class_name}()  # TODO: Add parameters

        # Assert
        assert obj is not None
        # TODO: Verify initialization

'''

    # Add tests for methods
    methods = class_info.get("methods", [])
    for method in methods[:3]:  # Limit to first 3 methods
        method_name = method.get("name")
        if method_name and not method_name.startswith('__'):
            template += f'''    def test_{method_name}_when_called_then_returns_expected(self, instance):
        """Test {method_name} method"""
        # Arrange
        # TODO: Set up method parameters

        # Act
        result = instance.{method_name}()  # TODO: Add parameters

        # Assert
        assert result is not None
        # TODO: Add specific assertions

'''

    return template


def _generate_integration_test_file(test_name: str, modules: List[str], workflow_desc: str) -> str:
    """Generate integration test file"""

    imports = f'''"""
Integration tests for {test_name}
Tests workflow: {workflow_desc}
Generated by Test Agent
"""

import pytest
from pathlib import Path
'''

    for module in modules:
        imports += f"from {module} import *\n"

    imports += "\n\n"

    test_class = f'''@pytest.mark.integration
class Test{test_name.replace('_', ' ').title().replace(' ', '')}:
    """Integration tests for {test_name} workflow"""

    @pytest.fixture
    def integration_setup(self, tmp_path):
        """Setup integration test environment"""
        # TODO: Set up test environment
        test_dir = tmp_path / "test_data"
        test_dir.mkdir()

        yield {{
            "test_dir": test_dir,
            # TODO: Add other setup data
        }}

        # Teardown happens automatically

    def test_happy_path_workflow(self, integration_setup):
        """Test complete happy path workflow"""
        # Arrange
        # TODO: Set up initial state

        # Act
        # TODO: Execute workflow steps
        # Step 1: ...
        # Step 2: ...
        # Step 3: ...

        # Assert
        # TODO: Verify end result
        assert True  # Placeholder

    def test_error_handling_workflow(self, integration_setup):
        """Test error handling through workflow"""
        # Arrange
        # TODO: Set up error condition

        # Act & Assert
        with pytest.raises(Exception):  # TODO: Specify exception
            # TODO: Execute workflow that should fail
            pass
'''

    return imports + test_class


def _generate_conftest_file(fixtures: List[Dict]) -> str:
    """Generate conftest.py content"""

    content = '''"""
Shared pytest fixtures and configuration
Generated by Test Agent
"""

import pytest
from pathlib import Path
from unittest.mock import Mock

'''

    # Add custom fixtures
    for fixture in fixtures:
        fixture_name = fixture.get("name", "sample_data")
        fixture_type = fixture.get("type", "data")
        scope = fixture.get("scope", "function")

        if fixture_type == "data":
            content += f'''
@pytest.fixture(scope="{scope}")
def {fixture_name}():
    """Provide {fixture_name} for testing"""
    return {{
        # TODO: Define fixture data
    }}

'''
        elif fixture_type == "file":
            content += f'''
@pytest.fixture
def {fixture_name}(tmp_path):
    """Create {fixture_name} for testing"""
    file_path = tmp_path / "test_file.txt"
    file_path.write_text("test content")
    return file_path

'''
        elif fixture_type == "mock":
            content += f'''
@pytest.fixture
def {fixture_name}():
    """Mock {fixture_name}"""
    mock = Mock()
    mock.method.return_value = "mocked"
    return mock

'''

    # Add pytest configuration
    content += '''
# ===== Pytest Configuration =====

def pytest_configure(config):
    """Configure pytest"""
    config.addinivalue_line(
        "markers", "slow: marks tests as slow (deselect with '-m \\"not slow\\"')"
    )
    config.addinivalue_line(
        "markers", "integration: marks tests as integration tests"
    )
'''

    return content


def _needs_mocking(func_info: Dict) -> bool:
    """Determine if function likely needs mocking"""
    func_name = func_info.get("name", "").lower()

    # Check function name for keywords
    keywords = ["request", "fetch", "api", "http", "read", "write", "save", "load", "query"]

    return any(keyword in func_name for keyword in keywords)
